<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>배열</title>
    <style>
      .area {
        width: 300px;
        border: 1px solid red;
      }

      .small {
        height: 100px;
      }

      .big {
        height: 200px;
      }
    </style>
  </head>

  <body>
    <h1>배열</h1>

    <pre>
        자바스크립트에서는 변수 선언 시 자료형 지정이 없기 때문에
        어떤 자료형의 값이든 다 하나의 배열 공간에 담을 수 있음
        -> 자바에서의 ArrayList와 유사함
    </pre>

    <button id="arrayBtn">확인하기</button>

    <div id="area1" class="area small"></div>

    <script>
      const area1 = document.querySelector('#area1');
      const arrayBtn = document.querySelector('#arrayBtn');
      function arrayTest() {
        // 테스트용 배열 생성
        var arr = ['홍길동', '서울', 20, true, [1, 2, 3]]; // 배열 객체

        console.log(arr);
        console.log(arr[2]); // 20
        console.log(arr[3]); // true
        console.log(arr[4]); // [1, 2, 3]

        console.log(arr[4][0]); // 1

        // for문
        // for (let i = 0; i < arr.length; i++) {
        // area1.innerHTML += arr[i] + '<br>';
        // }

        // 배열의 0번 인덱스에서부터 마지막 인덱스까지 순차적으로 모두 접근하고자 할 때
        // for in문 활용 가능
        // for(var 변수명 in 순차적으로 접근하고자하는 배열명)
        for (const i in arr) {
          area1.innerHTML += arr[i] + '<br>';
        }
      }

      arrayBtn.addEventListener('click', arrayTest);
    </script>

    <hr />

    <h3>* 배열의 선언</h3>

    <pre>
        배열의 선언 시 배열의 크기를 지정한 채로 선언하거나, 크기를 지정하지 않아도 됨
        (배열의 크기의 제약이 없다)
    </pre>

    <button id="arrayBtn2">확인하기</button>

    <script>
      function arrayTest2() {
        const arrayBtn2 = document.querySelector('#arrayBtn2');

        // 자바스크립트에서의 배열 선언법
        var arr1 = new Array(); // 배열의 크기가 0인 빈 배열
        var arr2 = new Array(3); // 배열의 크기가 3인 빈 배열
        var arr3 = []; // 배열의 크기가 0인 빈 배열

        console.log(arr1);
        console.log(arr2);
        console.log(arr3);

        // 만들어진 배열에 값 대입
        arr1[0] = '바나나';
        arr1[1] = '사과';
        arr1[10] = '키위'; // 배열의 크기가 11로 늘어나있다. [2]~[9] 까지는 비어있다

        console.log(arr1);

        arr2[0] = '자동차';
        arr2[1] = '기차';
        arr2[2] = '도보';
        arr2[3] = '비행기';

        console.log(arr2);

        // 배열 선언과 동시에 초기화
        var arr4 = new Array('홍길동', '임꺽정');
        var arr5 = new Array('java', 'oracle', 'front-end');

        console.log(arr4);
        console.log(arr5);
      }

      arrayBtn2.addEventListener('click', arrayTest2);
    </script>

    <hr />

    <h3>* Array 객체의 메소드</h3>

    <h4>1) indexOf(찾고자하는요소) : 배열에서 해당 요소가 위치해있는 인덱스를 반환</h4>

    <div id="area2" class="area small"></div>

    <button id="btn2">확인하기</button>

    <script>
      const btn2 = document.querySelector('#btn2');
      const area2 = document.querySelector('#area2');
      function indexOfTest() {
        // 테스트용 배열 만들기
        var arr = ['사과', '딸기', '바나나', '복숭아', '파인애플'];

        // 찾고자하는 과일을 사용자로부터 입력받는 구문
        const fruit = prompt('찾고자하는 과일명을 입력해주세요.');
        const index = arr.indexOf(fruit);
        // 해당 과일이 있다면 그 과일의 인덱스 값을 반환
        // 배열에 존재하지 않는 요소를 입력 시 -1을 반환

        console.log(index);

        area2.innerHTML = `당신이 찾는 과일 ${fruit}은(는)`;
        if (index === -1) {
          area2.innerHTML += '판매하지 않습니다.';
        } else {
          area2.innerHTML += `${index}번째 인덱스에 있습니다.`;
        }
        // 있을 경우 : 당신이 찾는 과일 xxx은 x번째 인덱스에 있습니다.
        // 없을 경우 : 당신이 찾는 과일 xxx은 판매하지 않습니다.

        // 참고
        console.log(1 == 1); // true
        console.log(1 == '1'); // true
        // == : 동등연산자, type과 무관하게 실제 값만 비교하여 일치하면 true 리턴

        console.log(1 === 1);
        console.log(1 === '1');
        // === : 일치연산자, type과 리터럴 둘 다 비교하여 일치하면 true 리턴
      }

      btn2.addEventListener('click', indexOfTest);
    </script>

    <hr />

    <h4>2) concat(배열, 배열, ...) : 여러 개의 배열을 결합하고자 할 때 사용</h4>

    <div id="area3" class="area big"></div>
    <button id="btn3">확인하기</button>

    <script>
      const area3 = document.querySelector('#area3');
      const btn3 = document.querySelector('#btn3');

      function concatTest() {
        // 테스트용 배열
        const arr1 = ['사과', '딸기'];
        const arr2 = ['자동차', '오토바이', '비행기'];

        area3.innerHTML = `arr1 : ${arr1} <br>`;
        area3.innerHTML += `arr2 : ${arr2} <br>`;

        area3.innerHTML += `arr1 기준으로 배열 합침 : ${arr1.concat(arr2)} <br>`;
        area3.innerHTML += `다시 arr1: ${arr1} <br>`;
        // concat은 원본 배열에 영향을 끼치지 않는 함수
        // -> 두 개의 배열을 합쳐서 새로운 배열로 만들어서 리턴

        area3.innerHTML += `arr2 기준으로 배열 함침 : ${arr2.concat(arr1)} <br>`;
        area3.innerHTML += `여러개의 배열 합침 : ${arr1.concat(arr2, [1, 2, 3])} <br>`;
      }
      btn3.addEventListener('click', concatTest);
    </script>

    <hr />

    <h4>3) reverse() : 배열 인덱스 값들을 역순으로 바꿔주는 메소드</h4>

    <div id="area4" class="area small"></div>
    <button id="btn4">확인하기</button>

    <script>
      const area4 = document.querySelector('#area4');
      const btn4 = document.querySelector('#btn4');

      function reverseTest() {
        // 테스트용 배열 생성
        const arr = [1, 2, 3, 4, 5];

        area4.innerHTML = `arr : ${arr} <br>`;
        area4.innerHTML += `reverse 결과 : ${arr.reverse()} <br>`;
        area4.innerHTML += `다시 arr : ${arr} <br>`;
        // reverse 함수는 원본 배열에 영향을 끼침.
      }
      btn4.addEventListener('click', reverseTest);
    </script>

    <h4>4) sort() : 배열 안에 담긴 값들을 오름차순으로 정렬시켜주는 함수(문자열만 가능)</h4>

    <div id="area5" class="area small"></div>
    <button id="btn5">확인하기</button>

    <script>
      const area5 = document.querySelector('#area5');
      const btn5 = document.querySelector('#btn5');

      function sortTest() {
        // 테스트용 배열
        const arr = ['김가현', '김카현', '김타현', '김차현', '김나현', '김하뎐'];

        area5.innerHTML = `원본 arr : ${arr} <br>`;
        area5.innerHTML += `sort 정렬 후 : ${arr.sort()} <br>`;
        area5.innerHTML += `원본이 바뀌었을가여 : ${arr} <br>`;
        // 바뀌었읍니다
        area5.innerHTML += `내림차순으로 하면 : ${arr.sort().reverse()} <br>`;
      }

      btn5.addEventListener('click', sortTest);
    </script>

    <hr />

    <h4>
      5_1) push(추가할요소) : 배열의 맨 뒤에 요소를 추가하고 배열의 크기를 반환
      <br />
      5_2) pop() : 배열의 맨 뒤 요소를 제거하고 제거된 요소를 반환
    </h4>

    <div id="area6" class="area big"></div>
    <button id="btn6">확인하기</button>

    <script>
      const area6 = document.querySelector('#area6');
      const btn6 = document.querySelector('#btn6');

      function pushPopTest() {
        let arr = ['서초동', '방배동', '역삼동', '삼성동', '대치동'];
        console.log(arr);

        area6.innerHTML = `arr : ${arr} <br>`;
        arr.push('신사동');
        console.log(arr);

        area6.innerHTML += `arr에 push 후 : ${arr} <br>`;
        area6.innerHTML += `arr의 push 후 arr의 크기 ${arr.push('논현동')} <br>`;
        area6.innerHTML += `다시 arr : ${arr} <br>`;

        area6.innerHTML += `arr에 pop 후 : ${arr.pop()} <br>`;
        area6.innerHTML += `다시 arr : ${arr} <br>`;

        // 원본 배열에 영향을 끼치는 메소드
        arr.pop();
        arr.pop();
        arr.pop();

        area6.innerHTML += `최종 arr : ${arr} <br>`;
      }

      btn6.addEventListener('click', pushPopTest);
    </script>

    <hr />

    <h4>
      6_1) unshift(추가할 요소) : 배열의 맨 앞에 요소를 추가 후 배열의 크기를 반환 <br />
      6_2) shift() : 배열의 맨 앞 요소를 제거하고 제거된 요소를 반환
    </h4>

    <div id="area7" class="area big"></div>
    <button id="btn7"></button>

    <script>
      const area7 = document.querySelector('#area7');
      const btn7 = document.querySelector('#btn7');

      function shiftUnshift() {
        let arr = ['야구', '볼링', '테니스', '탁구'];

        area7.innerHTML = `arr : ${arr} + <br>`;
        arr.unshift('농구');
        area7.innerHTML += `arr에 unshift 후 : ${arr} <br>`;
        area7.innerHTML += `arr에 unshift 후 배열의 크기 : ${arr.unshift('당구')}`;
        area7.innerHTML += `다시 arr : ${arr} <br>`;

        area7.innerHTML += `arr에 shift : ${arr.shift()} <br>`;
        area7.innerHTML += `다시 arr : ${arr} <br>`;

        //원본 배열에 영향을 미치는 메소드
      }

      btn7.addEventListener('click', shiftUnshift);
    </script>

    <hr />

    <h4>
      7_1) slice(시작, 끝) : 배열 안의 요소들을 단지 추출만 해주는 함수<br />
      7_2) splice(시작, 제거수, 추가값) : 배열의 요소를 추출해서 제거 및 추가, 추가 값은 생략 가능 생략 시 제거만 한다.
    </h4>

    <div id="area8" class="area small"></div>
    <button id="btn8">확인하기</button>

    <script>
      area8 = document.querySelector('#area8');
      btn8 = document.querySelector('#btn8');

      function sliceSpliceTest() {
        // 테스트용 배열
        let arr = ['자바', '오라클', 'html', 'css', 'javascript'];

        area8.innerHTML = `arr : ${arr} <br>`;

        // slice(시작인덱스, 끝인덱스) : 시작인덱스에서부터 끝인덱스 -1까지 추출
        area8.innerHTML += `slice 결과 : ${arr.slice(2, 4)} <br>`;
        area8.innerHTML += `다시 arr : ${arr} <br>`;
        // slice 함수는 원본 배열에 영향을 미치지 않는다.

        // splice(시작 인덱스, 제거 수 , 추가할 요소)
        // 추가할 요소를 생략한 경우 부분적인 요소들을 제거만 시켜주지만
        // 추가할 요소를 생략하지 않은 경우 부분적인 요소들을 제거 후 그 자리에 새로운 요소를 추가
        area8.innerHTML += `splice 결과 : ${arr.splice(2, 2, 'spring')} <br>`;
        area8.innerHTML += `최종 arr : ${arr} <br>`;

        // splice는 원본 배열에 영향을 미친다
      }
      btn8.addEventListener('click', sliceSpliceTest);
    </script>

    <hr />

    <h4>8) join(구분자) / toString() : 배열에 담긴 값들을 하나의 "문자열"로 합쳐서 반환해주는 메소드</h4>

    <div id="area9" class="area small"></div>
    <button id="btn9">확인하기</button>

    <script>
      const area9 = document.querySelector('#area9');
      const btn9 = document.querySelector('#btn9');

      function toStringJoinTest() {
        // 테스트용 배열
        let arr = ['나는', '오늘부터', '다이어트를', '시작한다!!'];

        area9.innerHTML = `arr : ${arr} <br>`;
        area9.innerHTML += `arr.toString() : ${arr.toString()} <br>`;
        // 배열 객체를 html 요소 내부에 출력할 경우 내부적으로 toString() 호출 후 리턴 결과 출력

        area9.innerHTML += `join() : ${arr.join()} <br>`;
        // 구분자 생략 시 ,를 통해 하나의 문자열로 합쳐줌
        // join 메소드 호출 시 구분자를 제시하면 해당 구분자로 하나의 문자열로 합쳐줌

        area9.innerHTML += `구분자를 제시한 join : ${arr.join(' ')} <br>`;
      }

      btn9.addEventListener('click', toStringJoinTest);
    </script>
  </body>
</html>
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
